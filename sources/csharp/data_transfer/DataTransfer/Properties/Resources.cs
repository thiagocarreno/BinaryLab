using System;
using System.CodeDom.Compiler;
using System.Globalization;
using System.Resources;
using System.Threading;

namespace DataTransfer.Properties.Resources
{
	/// <summary>
    ///     Strongly-typed and parameterized string resources.
    /// </summary>
    [GeneratedCode("Resources.tt", "1.0.0.0")]
    internal static class Strings
    {
        /// <summary>
        ///     A string like "The parameter '{0}' not accepts extension."
        /// </summary>
        internal static string ArgumentNotAcceptsExtensionMessage(object p0)
        {
            return DataTransferResource.GetString(DataTransferResource.ArgumentNotAcceptsExtensionMessage, p0);
        }

        /// <summary>
        ///     A string like "The '{0}' cannot be null."
        /// </summary>
        internal static string ArgumentNullExceptionMessage(object p0)
        {
            return DataTransferResource.GetString(DataTransferResource.ArgumentNullExceptionMessage, p0);
        }

        /// <summary>
        ///     A string like "Configuration '{0}' not found."
        /// </summary>
        internal static string ConfigurationNotFound(object p0)
        {
            return DataTransferResource.GetString(DataTransferResource.ConfigurationNotFound, p0);
        }

        /// <summary>
        ///     A string like "The transfer for invariant name '{0}' is specified multiple times in the application configuration. The invariant name must be unique for each configured provider."
        /// </summary>
        internal static string TransferInvariantRepeatedInConfig(object p0)
        {
            return DataTransferResource.GetString(DataTransferResource.TransferInvariantRepeatedInConfig, p0);
        }
    }

	/// <summary>
    ///     Strongly-typed and parameterized exception factory.
    /// </summary>
    [GeneratedCode("Resources.tt", "1.0.0.0")]
    internal static class Error
    {
		/// <summary>
        ///     The exception that is thrown when the value of an argument is outside the allowable range of values as defined by the invoked method.
        /// </summary>
        internal static Exception ArgumentOutOfRange(string paramName, string message)
        {
            return new ArgumentOutOfRangeException(paramName, message);
        }

		/// <summary>
        ///     The exception that is thrown when the author has yet to implement the logic at this point in the program. This can act as an exception based TODO tag.
        /// </summary>
        internal static Exception NotImplemented()
        {
            return new NotImplementedException();
        }

        /// <summary>
        ///     The exception that is thrown when an invoked method is not supported, or when there is an attempt to
        ///     read, seek, or write to a stream that does not support the invoked functionality.
        /// </summary>
        internal static Exception NotSupported()
        {
            return new NotSupportedException();
        }
	}

	/// <summary>
    ///     AutoGenerated resource class. Usage:
    ///     string s = EntityRes.GetString(EntityRes.MyIdenfitier);
    /// </summary>
    [GeneratedCode("Resources.tt", "1.0.0.0")]
    internal sealed class DataTransferResource
    {
        internal const string ArgumentNotAcceptsExtensionMessage = "ArgumentNotAcceptsExtensionMessage";
        internal const string ArgumentNullExceptionMessage = "ArgumentNullExceptionMessage";
        internal const string ConfigurationNotFound = "ConfigurationNotFound";
        internal const string TransferInvariantRepeatedInConfig = "TransferInvariantRepeatedInConfig";

		private static DataTransferResource loader;
        private readonly ResourceManager resources;

		private DataTransferResource()
        {
            resources = new ResourceManager(
                "DataTransfer.Properties.Resources", typeof(DataTransfer.Properties.Resources.DataTransferResource).Assembly);
        }

        private static DataTransferResource GetLoader()
        {
            if (loader == null)
            {
                var sr = new DataTransferResource();
                Interlocked.CompareExchange(ref loader, sr, null);
            }
            return loader;
        }

        private static CultureInfo Culture
        {
            get
			{ 
				return CultureInfo.CurrentUICulture;
			}
        }

        public static ResourceManager Resources
        {
            get
			{
				var loader = GetLoader();
				return loader.resources;
			}
        }

        public static string GetString(string name, params object[] args)
        {
            var sys = GetLoader();
            if (sys == null)
            {
                return null;
            }

            var res = sys.resources.GetString(name, Culture);

            if (args != null
                && args.Length > 0)
            {
                for (var i = 0; i < args.Length; i ++)
                {
                    var value = args[i] as String;
                    if (value != null
                        && value.Length > 1024)
                    {
                        args[i] = value.Substring(0, 1024 - 3) + "...";
                    }
                }
                return String.Format(CultureInfo.CurrentCulture, res, args);
            }
            else
            {
                return res;
            }
        }

        public static string GetString(string name)
        {
            var sys = GetLoader();
            if (sys == null)
            {
                return null;
            }
            return sys.resources.GetString(name, Culture);
        }

        public static string GetString(string name, out bool usedFallback)
        {
            // always false for this version of gensr
            usedFallback = false;
            return GetString(name);
        }

        public static object GetObject(string name)
        {
            var sys = GetLoader();
            if (sys == null)
            {
                return null;
            }
            return sys.resources.GetObject(name, Culture);
        }
	}
}